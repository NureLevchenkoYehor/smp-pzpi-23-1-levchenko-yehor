Міністерство освіти та науки України
Харківський національний університет радіоелектроніки


Кафедра програмної інженерії






ЗВІТ
ПРО ЛАБОРАТОРНУ РОБОТУ №1
з дисципліни «Скриптові мови програмування»






Виконав:
ст. гр. ПЗПІ-23-1
Левченко Є.Д.

Перевірив:
Ст. викл. кафедри ПІ
Сокорчук І.П.

Харків, 2025 р. 

Лабораторна робота №1
     1 Мета роботи
     Ознайомитися з основними командами Bash для роботи з файлами та текстовими даними. Навчитися використовувати команди select, ls, awk, sort, uniq, tee, cat, sed, iconv тощо. Розробити Bash-скрипт для перетворення CSV файла розкладу занять у придатний для імпорту в Google Календар CSV формат.  
     2 Задача
     Розробити Bash-скрипт, який обробляє експортований із сайту https://cist.nure.ua розклад занять для всіх груп потоку в форматі CSV та перетворює його у формат CSV для імпорту в Google Календар.
     Скрипт має підтримувати ключі help, version, q та quiet. При використанні ключа help, користувачу має бути виведено довідку, з успішним завершенням програми. При використанні ключа version, користувачу має бути виведено інформацію про версію програми, з успішним завершенням програми. Використання ключа q або quiet повинно попередити виведення інформації в стандартний потік виведення.
     В якості аргументів, скрипт має приймати шлях до файлу або назву академічної групи та шлях до файлу. Якщо при виклику не були передані аргументи, скрипт повинен вивести меню вибору файлу select та сформувати відсортований за датою в іменах файлів список доступних у поточній директорії CSV файлів за шаблоном TimeTable_??_??_20??.csv. Після того, як файл буде обрано, він має відкрити та згенерувати список академічних груп, що містяться у файлі, відсортувати їх за алфавітом та вивести меню вибору групи за допомогою select.
     Правила обробки вмісту файлу:
* значення для стовпчику «Subject» повинні формуватися на основі стовпчику «Тема» вхідного CSV файлу,  але без назви академічної групи та дефіса на початку цього поля. В кінці, має додаватися крапка з комою та порядковий номер заняття. Порядковий номер визначається із врахуванням того, що лабораторні роботи складаються із двох пар, а решта занять – із однієї;
* значення для стовпців «Start Date», «Start Time», «End Date» та «End Time» мають братися з відповідних стовпців «Дата начала», «Время начала», «Дата завершения» та «Время завершения» та приводитись до американського формату дати та часу у відповідності до вимог Google Календарю;
* значення для стовпцю «Description» копіюються зі стовпцю «Описание»;
* послідовність стовпців у вихідному файлі: «Subject», «Start Date», «Start Time», «End Date», «End Time», «Description».
     Дані, створені для Google Календаря необхідно виводити у стандартний потік виводу, якщо це не заблоковано ключем q або quiet.
     Результат роботи має бути збережено у новий файл, назва якого буде складатися з назви вхідного CSV файлу та префіксу «Google_».
     Якщо файл не знайдено або файл є недоступним для читання, вивести повідомлення про помилку в стандартний потік помилок та повернути код помилки
     Правила обробки помилок:
* якщо файл не знайдено або файл є недоступним для читання, вивести повідомлення про помилку в стандартний потік помилок та повернути код помилки;
* якщо група не знайдена у вибраному файлі, повідомити про це користувача та запропонувати вибір іншої групи;
* якщо група не вказана, але у вказаному файлі присутня лише одна група, створити CSV файл Google Календаря для цієї групи;
* якщо сталася помилка під час обробки файлу, повідомити про це та завершити роботу з відповідним кодом помилки.
     В якості коду помилки дозволено використовувати значення не більші за 100.
     Окрім цього, файл скрипту має бути виконуваним для всіх користувачів, з дозволом редагування лише для власника.
     3 Хід роботи
     Створюємо файл, задаємо відповідні правила доступу, відкриваємо та визначаємо в ньому шебанг.
     Для кращого контролю над виведенням інформації, створимо допоміжні функції [додаток А, рядки 3-9], які будуть виводити повідомлення у потік помилок та потік виведення відповідно, застосовуючи будь-яку додаткову логіку. Так само, створимо допоміжні функції для виводу довідки та версії скрипту [додаток А, рядки 10-29].
     Створимо функцію для обробки вхідних аргументів, яка виконає їх нормалізацію та ініціалізує відповідні прапори роботи [додаток А, рядки 34-67].
     Далі, нам потрібна функція, яка буде запитувати у користувача обрати файл, у відповідності до визначеного шаблону та повертати його, або виходити з відповідною помилкою [додаток А, рядки 71-87]. Окрім цього, нам знадобиться функція для перевірки файлу на читання та запис.
     Для отримання даних з CSV, створимо функцію, яка буде повертати потік даних, з виправленими символами кінця рядку та у відповідному кодуванні [додаток А, рядки 108-111]. Далі, для отримання з цього потоку даних груп, створимо відповідну функцію, яка знайде та відсортує усі унікальні входження [додаток А, рядки 116-122]. Відповідно, ця функція буде використовуватись у функції для вибору групи [додаток А, рядки 126-141].
     Після того, як всі необхідні функції були написані, ініціалізуємо глобальні змінні та почнемо з попередньої обробки CSV файлу. Обробимо аргументи і прапори, якщо такі є. Після чого, якщо файл не було визначено, запитаємо користувача вибрати файл. Потім перевіряємо файл і отримуємо дані, якщо перевірки пройдено. Далі програма отримає список груп з даних. Якщо у списку не буде жодної групи, то будемо вважати, що файл має бути створено для однієї групи, згаданої у файлі, ігноруючи ту, що була передана як аргумент. Якщо групи є, програма перевірить, чи є поточна група у списку, і запитає у користувача вибрати одну з них, якщо групи немає у списку [додаток А, рядки 156-186].
     Далі, можна перейти до основної роботи із даними [додаток А, рядки 198-247]. Для цього, будуть створені AWK функції для форматування дати та часу [додаток А, рядки 200-212], а також для скорочення початку рядку, для випадку з декількома групами [додаток А, рядки 213-216]. Змінимо порядок полів усіх рядків, для сортування за датою та часом початку, та відкинемо заголовок таблиці.
     Наступним кроком, додамо до відсортованих та частково відформатованих даних необхідну порядкову нумерацію, замінюючи порядок полів рядків відповідно до вимог, та відсортуємо для групування предметів та кращої читабельності вихідного файлу [додаток А, рядки 248-259].
     Нарешті, збережемо дані у файл, додавши заголовок до таблиці [додаток А, рядки 260-270].
     Висновок: у ході виконання лабораторної роботи, я ознайомився з командами Bash для роботи з файлами та текстовими даними. В результаті, було створено програму для перетворення CSV файла розкладу занять у придатний для імпорту в Google Календар CSV формат, який було успішно використано.
     
     
     

ДОДАТОК А
Вихідний код
  1 #! /bin/bash
  2 # Helper Functions =========================================
  3 function err() {
  4   echo "[$(date +'%Y-%m-%dT%H:%M:%S%z')]: $*" >&2
  5 }
  6 function out() {
  7   if $quiet; then return; fi
  8   echo "$*"
  9 }
 10 function showHelp() {
 11 cat << EOF
 12 Використання: 
 13  $0 [[-h|--help] | [-v|--version]] | [[-q|--quiet] [академ_група] файл_із_cist.csv]
 14 Параметри:
 15  академ_група          Назва академічної групи (шаблон)
 16  файл_із_cist.csv      Експортований CSV-файл розкладу занять
 17 Опис:
 18  Перетворити CSV-файл розкладу занять у придатний для імпорту в Google Календар CSV-формат
 19 Опції:
 20  -h, --help            Вивести довідку.
 21  -v, --version         Вивести інформацію про версію.
 22  -q, --quiet           Не виводити інформацію в стандартний потік виведення.
 23 EOF
 24 }
 25 function showVersion() {
 26 cat << EOF
 27 1.0.0
 28 EOF
 29 }
 30 # Main Functions ===========================================
 31 # Processes current arguments, removes flags and sets the global variables.
 32 # Params: original argument list
 33 # Modifies: arguments list, student_group, csv_file, quiet.
 34 function process_args() {
 35   # Normilize initial arguments
 36   options="$(getopt -l "help,version,quiet" -o "hvq" -a -- "$@")"
 37   eval set -- "$options"
 38   # Process flags
 39   while true; do
 40       case "$1" in
 41       -h|--help) 
 42           showHelp
 43           exit 0
 44           ;;
 45       -v|--version) 
 46           showVersion
 47           exit 0
 48           ;;
 49       -q|--quiet)
 50           quiet=true
 51           ;;
 52       --)
 53           shift
 54           break;;
 55       esac
 56       shift
 57   done
 58   
 59   # Init student group, if given, and csv_file
 60   if [ $# -gt 1 ]; then
 61     group="$1"
 62     shift
 63   fi
 64   echo "Arg $1: $1"
 65   csv_file="$1"
 66   shift
 67 }
 68 # Promts user to select a CSV file matching the pattern.
 69 # Return: File name
 70 #         Or exit code 1
 71 function select_file() {
 72   local file
 73   select file in $(ls | grep '^TimeTable_.._.._20..\.csv$' | sort -u) 'Вийти'; do 
 74     case "$file" in
 75       '')
 76         continue
 77         ;;
 78       'Вийти')
 79         exit 1
 80         ;;
 81       *)
 82         echo "$file"
 83         return 0
 84         ;;
 85     esac
 86   done
 87 }
 88 # Checks if file exists and is writable, and exit if not.
 89 # Params: File name.
 90 # Returns: 4 - File do not exists;
 91 #          3 - File is read-only;
 92 #          0 - File is fine.
 93 function check_file() {
 94   local file="$1"
 95   # Check file existance
 96   if [ ! -f "$file" ]; then
 97     return 4
 98   fi
 99   # Check if the file is read-only
100   if [ ! -r "$file" ]; then
101     return 3
102   fi
103   return 0
104 }
105 # Get the data from CSV in appropriate format.
106 # Params: File name.
107 # Returns: Raw CSV data with fixed line endings in UTF-8.
108 function get_raw_data() {
109   local file="$1"
110   sed 's/\r/\r\n/g' < "$file" | iconv -f cp1251 -t utf8
111 }
112 # Get a set of groups from the CSV
113 # Params: Raw CSV data (from stdin)
114 # Returns: List of groups separated by new line;
115 #          Empty string, if file was created for a single group.
116 function get_groups() {
117     gawk -vFPAT='[^,]*|"[^"]*"' 'NR!=1 && /"([^"]+) - / {
118     gsub(/"/, "", $1)
119     split($1, g, " - ")
120     printf("%s\n", g[1])
121   }' | sort | uniq
122 }
123 # Promts user to select a group.
124 # Return: Group identifier
125 #         Or exit code 1
126 function select_group() {
127   groups="$*"
128   select group in $groups 'Завершити роботу'; do
129     case $group in
130       '')
131         ;;
132       'Завершити роботу')
133         exit 1
134         ;;
135       *)
136         echo "$group"
137         break
138         ;;
139     esac
140   done
141 }
142 # Implementation ===========================================
143 ## Globals =================================================
144 quiet=false
145 group=''
146 csv_file=''
147 ## Pre-Process =============================================
148 # Process arguments and flags, if any.
149 # After that, if csv_file wasn't initialized, asks user to select a file.
150 # Then, checks the file and gets the data, if checks are passed.
151 # Next, it gets list of groups from the data.
152 # If there was no group in list it is considered that file should be created 
153 # for a single group mentioned in the file, ignoring one that was passed as an argument.
154 # If there are groups, checks if current group is in list and asks user to select one,
155 # if the group is not in the list.
156 if (($# > 0)); then process_args "$@"; fi
157 if [ -z "$csv_file" ]; then csv_file="$(select_file)"; fi
158 if [[ $? == 1 ]]; then exit 0; fi
159 check_file "$csv_file"
160 case $? in
161   0) # All checks passed, continue processing
162     ;;
163   3) # File not readable
164     err "Файл $file недоступний для читання."
165     exit 3
166     ;;
167   4) # File not found
168     err "Файл $file не знайдено."
169     exit 4
170     ;;
171 esac
172 raw_data="$(get_raw_data "$csv_file")"
173 groups="$(get_groups <<< "$raw_data")"
174 if [ -n "$groups" ]; then
175   if [ -n "$group" ] && ! echo "$groups" | grep -Fxq "$group"; then 
176     out "Група $group відсутня у файлі."
177     group=''
178   fi
179   if [ -z "$group" ]; then
180     out 'Оберіть групу для формування розкладу:'
181     group=$(select_group "$groups")
182   fi
183   if [[ $? == 1 ]]; then exit 0; fi
184 else
185   group=''
186 fi
187 # Processing ===============================================
188 if [ -z "$group" ]; then
189   out "Обробка файлу $csv_file як призначеного для однієї групи..."
190 else
191   out "Обробка файлу $csv_file як призначеного для групи $group..."
192 fi
193 # echo "Pattern: ^\"$group - "
194 # gawk -vFPAT='[^,]*|"[^"]*"' '
195 #     NR != 1 {
196 #         print "Checking:"
197 #     }' <<< "$raw_data" > output.txt
198 if [ -n "$group" ]; then
199   ordered_data=$(gawk -vFPAT='[^,]*|"[^"]*"' -v group="$group" '
200       function format_date(date) {
201       gsub(/"/, "", date)
202       split(date, d, ".")
203       return sprintf("\"%02d/%02d/%04d\"", d[2], d[1], d[3])
204     }
205     function format_time(time) {
206       gsub(/"/, "", time)
207       split(time, t, ":") # hh:mm:ss # $1 $2 $3
208       if (t[1] == "00" && t[2] == "00" && t[3] == "00") return sprintf("\"%02d:%02d AM\"", t[1], t[2])
209       if (t[1] == "12" && t[2] == "00" && t[3] == "00") return sprintf("\"%02d:%02d KekPM\"", t[1], t[2])
210       if (t[1] >= 12) return sprintf("\"%02d:%02d PM\"", t[1] - 12, t[2])
211       return sprintf("\"%02d:%02d AM\"", t[1], t[2])
212     }
213     function trim_start(str, prefix) {
214       gsub("^" prefix, "", str)
215       return sprintf("\"%s", str)
216     }
217     NR!=1 && $0 ~ ("^\"" group " - ") {
218       $2 = format_date($2)
219       $3 = format_time($3)
220       $4 = format_date($4)
221       $5 = format_time($5)
222       $1 = trim_start($1, "\"" group " - ")
223       print $2, $3, $4, $5, $1, $12
224     }' OFS=',' <<< "$raw_data" | sort)
225 else
226   ordered_data=$(gawk -vFPAT='[^,]*|"[^"]*"' -v group="$group" '
227       function format_date(date) {
228       gsub(/"/, "", date)
229       split(date, d, ".")
230       return sprintf("\"%02d/%02d/%04d\"", d[2], d[1], d[3])
231     }
232     function format_time(time) {
233       gsub(/"/, "", time)
234       split(time, t, ":") # hh:mm:ss # $1 $2 $3
235       if (t[1] == "00" && t[2] == "00" && t[3] == "00") return sprintf("\"%02d:%02d AM\"", t[1], t[2])
236       if (t[1] == "12" && t[2] == "00" && t[3] == "00") return sprintf("\"%02d:%02d KekPM\"", t[1], t[2])
237       if (t[1] >= 12) return sprintf("\"%02d:%02d PM\"", t[1] - 12, t[2])
238       return sprintf("\"%02d:%02d AM\"", t[1], t[2])
239     }
240     NR!=1 {
241       $2 = format_date($2)
242       $3 = format_time($3)
243       $4 = format_date($4)
244       $5 = format_time($5)
245       print $2, $3, $4, $5, $1, $12
246     }' OFS=',' <<< "$raw_data" | sort)
247 fi
248 formatted_data=$(gawk -vFPAT='[^,]*|"[^"]*"' '
249   NR != 1 {
250     gsub(/"/, "", $5)
251     counter[$5]++
252     count = counter[$5]
253     if ($5 ~ /Лб/) {
254       count = int((count + 1) / 2)
255     }
256     $5 = "\"" $5 "; №" count "\""
257     print $5, $1, $2, $3, $4, $6
258   }
259 ' OFS=',' <<< "$ordered_data" | sort)
260 if "$quiet"; then
261   {
262     echo '"Subject","Start Date","Start Time","End Date","End Time","Description"'
263     echo "$formatted_data"
264   } > "Google_${csv_file%.csv}.csv"
265 else
266   {
267     echo '"Subject","Start Date","Start Time","End Date","End Time","Description"'
268     echo "$formatted_data"
269   } | tee "Google_${csv_file%.csv}.csv"
270 fi

